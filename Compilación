## PRÁCTICA 7 

## COMPILACIÓN DE PROGRAMAS.

## COMPILACIÓN CON gcc/g++

**GCC** es un compilador.(puede generar un programa ejecutable en lenguaje máquina)

**Preprocesador** 

Acepta como entrada un archivo en código fuente y elimina los comentarios e interpreta las directivas de preprocesamiento (#).

La más interesante:

		#include <archivo>
		#include "archivo.h"	sustituye la línea por el contenido del archivo.

**Compilador**

Analiza el código fuente y lo traduce a código objeto. (archivoinc.o --> módulo objeto)

**Enlazador**

Se encarga de resolver las referencias externas y generar un archivo ejecutable. 

El enlazador de GNU es ld.

(Para generar un archivo ejecutable es necesario que uno de los archivos ".o" contenga la función main(). )

**g++**

OPCIONES: 			FUNCIÓN

-c				|Solo realiza la etapa de preprocesado y compilación
-o 				|Te permite escribir el nombre del archivo ejecutable
-g				|Añade información necesaria para gdb de cara a poder depurar el programa


EJEMPLOS:

$ g++ -c main.cpp 	#genera, si no hay errores de compilación, el módulo objeto main.o

			**Cambiar el nombre al archivo ejecutable**

g++ -o programa1 main.cpp factorial.cpp hello.cpp   #genera el archivo ejecutable con el nombre programa1


CASOS:

	-Si nos sale: ld returned 1 exit status.
	La orden no se ha completado con éxito, el enlazador ld no ha podido resolver las referencias externas y no se ha generado el archivo main.o Eso es porque el main.cpp necesita de otros módulos que contengan dichas referencias externas.
	-Compilamos dichos módulos por separado.
		g++ -c factorial.cpp
		g++ -c hello.cpp
		g++ -c main.cpp
		g++ main.o factorial.o hello.o
	-Como resultado se obtiene el archivo ejecutable a.out

			**Borrar**
$ rm *.o programa a.out


## INTRODUCCIÓN A LAS BIBLIOTECAS

Biblioteca= colección de módulos objeto

Estos módulos contienen constantes, variables y funciones que pueden ser utilizados por otros módulos si se enlazan de forma adecuada.

Si disponemos de un conjunto de módulos objeto podemos generar una biblioteca utilizando la orden **ar** 

		**Para crear una biblioteca**
		#usamos **ar -rvs**
$ g++ -c sin.cpp
$ g++ -c cos.cpp
$ g++ -c tan.cpp
$ ar -rvs libmates.a sin.o cos.o tan.o

**$ ar -rvs libnombrebiblioteca.a modulo1.o modulo2.o modulo3.o**

(OBSERVACIÓN: Cuando creamos una biblioteca aparte de un archivo llamado libnombrebiblioteca.a se crea otro archivo llamado nombrebiblioteca.h

El nombre y las características de cada función, el prototipo, así como la definición de algunos tipos de datos y macros, se encuentran en un fichero denominado **archivo de cabecera** (con extensión ".h"))


		**Para crear un programa ejecutable que necesita especificar una biblioteca**


$ g++ -L./ -o programa2 main2.o factorial.o hello.o -lmates 			#Especifica donde está la biblioteca

$ g++ -I./includes -L./ -o programa2 main2.cpp factorial.cpp hello.cpp -lmates	#Especifica donde está la biblioteca y los archivos de cabecera


OPCIONES:

**-L**

La opcion -L permite especificar directorios en donde g++ puede buscar las bibliotecas necesarias. 

(Por omisión, g++ las busca en los directorios /lib y /usr/lib.)

**-I**

La opcion -I permite especificar directorios en donde g++ puede buscar los archivos de cabecera.

(Solo si los archivos de cabecera se encuentran en otro sitio distinto que la biblioteca)

**-l**

La opción -l busca la biblioteca cuya raíz es "nombrebiblioteca", con prefijo lib y sufijo .a , es decir, la biblioteca libnombrebiblioteca.a


(OBSERVACIÓN:

Cuando trabajas con varios módulos de código fuente se generan **dependencias**
Entonces si modificas uno de los módulos luego debes generar el módulo objeto correspondiente y generar de nuevo el programa1 y el programa2.)


## USO DE ARCHIVOS DE TIPO MAKEFILE

**make**

Permite gestionar las dependencias comprobando qué archivos se han modificado desde la última vez que se ejecutó para construir el archivo ejecutable.

En tal caso, vuelve a construirlo haciendo de nuevo sólo lo que sea necesario -> compilando exclusivamente aquellos archivos que hubieran sido modificados. 

INTERESANTE= podemos automatizar el proceso de compilación y enlazado construyendo un archivo de tipo **makefile** en el que se especifiquen las acciones a realizar.


##EJECUCIÓN DE LA UTILIDAD MAKE

**make**



OPCIONES:		FUNCIÓN

-f 			|Permite especificar el nombre de un archivo de tipo makefile. (Si el nombre elegido es makefileGNU makefile ó Makefile)
-p			|Nos muestras las variables predefinidass que se pueden usar dentro de las especificación de un archivo makefile


##ESTRUCTURA DE UN ARCHIVO MAKEFILE

Un archivo makefile está compuesto por una o varias **reglas**, cada una de las cuales estará asociada a la consecución de un objeto concreto.

Las reglas están formadas por un objetivo, una lista de dependencias(posiblemente vacía) y las acciones u órdenes que son necesarias para alcanzar dicho objetivo.

Para escribir comentarios: # en su primera columna.

		SINTAXIS BÁSICA PARA UNA REGLA:

objetivo1: dependencias
TABULADOR orden1
TABULADOR orden2
...
TABULADOR ordenN


El **objetivo**: -tiene que tener un nombre característico para la acción
		 -tiene que escribirse comenzando desde la primera columna de la línea
(suele coincidir con el nombre de un archivo)


		##EJEMPLO1(sin dependencias):
-->Queremos construir un programa ejecutable.(OBJETIVO)

programa1:
	g++ -I./includes -o programa1 main.cpp hello.cpp factorial.cpp

Si lo guardamos en un archivo makefile llamado "makefileX", :

carlotavm99@carlotavm99-Swift-SF314-52:~$ touch makefileX
carlotavm99@carlotavm99-Swift-SF314-52:~$ make -f makefileXmake: 'programa1' está actualizado.

		##EJEMPLO2(con varios objetivos y con dependencias):

programa1: main.o factorial.o hello.o
	g++ -o programa1 main.o factorial.o hello.o

main.o: main.cpp 
	g++ -I./includes -c main.cpp

factorial.o: factorial.cpp 
	g++ -I./includes -c factorial.cpp

hello.o: hello.cpp
	g++ -I./includes -c hello.cpp

		PROBLEMAS:

Si no existen los archivos objeto ni el ejecutable, la ejecución sería:

$ make –f makefileB
g++ -I./includes -c main.cpp
g++ -I./includes -c factorial.cpp
g++ -I./includes -c hello.cpp
g++ -o programa1 main.o factorial.o hello.o


Si no existe el archivo objeto factorial.o

$ make –f makefileB
g++ -I./includes -c factorial.cpp
g++ -o programa1 main.o factorial.o hello.o

		**Si se modifica un archivo de cabecera**

-Si no existe como dependencia: No se recompilaría

-Si existe como dependencia (de aquellos objetivos donde su archivo fuente lo incluya): 


programa1: main.o factorial.o hello.o
	g++ -o programa1 main.o factorial.o hello.o

main.o: main.cpp functions.h
	g++ -c main.cpp

factorial.o: factorial.cpp functions.h
	g++ -c factorial.cpp

hello.o: hello.cpp functions.h
	g++ -c hello.cpp


		**(OJO= Si el archivo de cabecera está en otro directorio:)**
			./includes/archivodecabecera.h
			-I./includes


programa1: main.o factorial.o hello.o
	g++ -o programa1 main.o factorial.o hello.o

main.o: main.cpp ./includes/functions.h
	g++ -I./includes -c main.cpp

factorial.o: factorial.cpp ./includes/functions.h
	g++ -I./includes -c factorial.cpp

hello.o: hello.cpp ./includes/functions.h
	g++ -I./includes -c hello.cpp

		
		**Regla sin órdenes asociadas: OBJETIVOS SIMBÓLICOS**

Comprobará que los archivos de la lista de dependencias están actualizados.


		**REGLAS VIRTUALES**

Invoca a un objetivo sin dependencias dentro de un archivo makefile cualquiera:

EJEMPLO:

···
···
clean:
	rm *.o

->Su ejecución sería: $ make -f makefile clean


## USO DE VARIABLES

VARIABLE		SIGNIFICADO

$@			|Representa el nombre del objetivo de la regla en la que nos encontramos
$<			|Representa la primera dependencia de la regla en la que nos encontramos
$?			|Representa las dependencias de la presente regla que hayan sido actualizadas (modificadas) del objetivo de la regla y separadas por un espacio en blanco
$^			|Representa todas las dependencias separadas por un espacio en blanco.

OTROS EJEMPLOS DE VARIABLES:

CC			#Indica el compilador que se va a utilizar
CPPFLAGS 		#Indica las opciones del compilador
SUBDIRECTORIO_DIR 	#Indica el directorio en donde se encuentran los archivos de cabecera
LIB_DIR			#Indica el directorio en donde se encuentran las bibliotecas
SRCS			#Indica las dependencias (.cpp)
OBJS			#Indica las dependencias (.o)
HDRS			#Indica el nombre de los archivos de cabecera

(La opción –Wall del compilador sirve para mostrar todos los warnings que pudieran aparecer durante el proceso de compilación.)

**USO DE $@**

programa1: $(OBJS)
	$(CC) -o $@ $(OBJS) 		#programa1 se sustituye por $@

**USO DE $<**

hello.o: hello.cpp
	$(CC) -c $(CPPFLAGS) $<		#hello.cpp se sustituye por $<


**USO DE $?**

print: $(SRCS)
	lpr -p $?			#$(SRCS) se sustituye por $?

**USO DE $^**

programa1: $(OBJS)
	$(CC) -o $@ $^			#$(OBJS) se sustituye por $^

##OTRAS OPCIONES Y VARIABLES

**-p**

-Se puede sustituir una secuencia de cadenas en una variable definida previamente.
		$(Nombre:TextoActual=TextoNuevo)

EJEMPLO:

Dada la variable SRCS = main.cpp factorial.cpp hello.cpp se puede crear otra, por ejemplo OBJS, en función de la existente simplemente sustituyendo su contenido de la siguiente forma:

	**OBJS=$(SRCS:.cpp=.o)**. De esta manera se obtiene OBJS = main.o factorial.o hello.o.













